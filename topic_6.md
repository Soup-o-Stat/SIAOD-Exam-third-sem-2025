# Алгоритм поиска в массивах

## Определение, виды и характеристики алгоритмов поиска
Алгоритм поиска — это метод нахождения нужного элемента в структуре данных, например, массиве или дереве

Виды алгоритмов поиска:
* Простые:
* * Линейный поиск
* * Бинарный поиск
* Улучшенные
* * интерполяционный поиск
* * Фибоначчиев поиск
* Поиск в структурах данных
* * поиск по бинарному дереву
* * Хэщ-поиск

Характеристики
* Точность: гарантирует ли нахождение элемента
* Скорость: вычислительная сложность алгоритма
* Структурные требования: работает ли с неупорядоченными данными

## Алгоритм линейного поиска, вычислительная сложность
Линейный поиск проверяет каждый элемент массива последовательно до нахождения нужного значения или завершения массива

Преимущества:
* Простота реализации
* Не требует упорядоченности данных

Недостатки: 
* Низкая производительность для больших массивов

Вычислительная сложность
* Лучший случай: O(1) — элемент находится первым
* Худший случай: O(n) — элемент находится последним или отсутствует
* Средний случай: O(n/2) ≈ O(n)

## Алгоритм бинарного поиска, особенность реализации, вычислительная сложность
Работает только с отсортированными массивами. Делит массив на две части, сравнивая искомый элемент с центральным:
* Если элемент меньше центрального — поиск продолжается в левой части
* Если больше — в правой

Особенности реализации:
* Требуется предварительная сортировка данных
* Реализация возможна через рекурсию или итерацию

Вычислительная сложность:
* Лучший случай: O(1) — элемент находится при первом сравнении
* Худший случай: O(log⁡n) — при n делениях массива
* Средний случай: O(log⁡n)

## Интерполяционный поиск, особенность реализации, вычислительная сложность
Оптимизированная версия бинарного поиска. Оценивает позицию искомого элемента в массиве, предполагая равномерное распределение значений

Особенности реализации:
* Подходит для равномерно распределённых массивов
* Если массив неравномерный, производительность падает

Вычислительная сложность:
* Лучший случай: O(1)
* Худший случай: O(n) — при неравномерном распределении
* Средний случай: O(log⁡log⁡n)

## Фибоначчиев поиск, особенность реализации, вычислительная сложность
Использует числа Фибоначчи для деления массива на части, что минимизирует количество сравнений. В отличие от бинарного поиска, разбиение не равное, а пропорциональное числам Фибоначчи

Шаги реализации:
* Определить наименьшее число Фибоначчи Fk​, большее или равное n
* Разбить массив по индексам, соответствующим Fk−2​ и Fk−1
* Повторять поиск в соответствующем разделе, уменьшая k

Вычислительная сложность:
* Лучший случай: O(1)
* Худший случай: O(log⁡n)

## Алгоритм поиска по бинарному дереву, вычислительная сложность
Применим к бинарным деревьям поиска (BST), где
* Левый потомок содержит элементы меньше корня
* Правый потомок содержит элементы больше корня

Шаги реализации:
* Сравнивать искомый элемент с текущим узлом
* Переходить в левое или правое поддерево в зависимости от результата
* Повторять до нахождения элемента или завершения дерева

Вычислительная сложность:
* Лучший случай: O(log⁡n) — дерево сбалансировано
* Худший случай: O(n) — дерево представляет собой цепочку