# Алгоритмы поиска по образцу

## Алгоритм прямого поиска в тексте по образцу, вычислительная сложность
Алгоритм проверяет вхождение образца (подстроки) в тексте, перебирая все возможные позиции начала образца в тексте

Шаги:
* Сравнить символы образца с символами текста, начиная с текущей позиции
* Если все символы совпадают, образец найден
* Если несовпадение — сдвинуть образец на одну позицию вправо и повторить сравнение

Преимущества:
* Простота реализации
* Подходит для небольших строк

Недостатки:
* Низкая производительность для больших текстов и длинных образцов

Вычислительная сложность:
* Худший случай: O(nm), где n — длина текста, m — длина образца
* Лучший случай: O(n), если совпадения находятся сразу

## Метод Кнута-Морриса-Пратта для поиска в тексте по образцу, понятие префикса, вычислительная сложность, эффективное применение

Алгоритм улучшает прямой поиск, используя предварительную обработку образца для создания таблицы префиксов. Это позволяет избежать повторных сравнений уже проверенных символов

Префикс — это начальная часть строки, которая совпадает с её суффиксом

Шаги алгоритма:
* Построить таблицу префиксов (Pi) для образца
* Использовать таблицу для ускоренного поиска, пропуская проверенные символы

Вычислительная сложность:
* Предварительная обработка образца: O(m)
* Поиск в тексте: O(n)
* Итоговая сложность: O(n+m)

Эффективное применение:
* Подходит для поиска в больших текстах или при многократных поисках одного образца.

## Алгоритм Бойера-Мура, его особенности, понятие таблицы смещений, вычислительная сложность

Алгоритм движется справа налево по образцу, начиная с конца. Использует таблицы смещений, чтобы пропускать ненужные проверки

Понятие таблицы смещений:
* Правило плохого символа: Определяет, насколько нужно сдвинуть образец, если текущий символ в тексте не совпал с символом в образце
* Правило хорошего суффикса: Использует информацию о совпавшем суффиксе для определения сдвига

Особенности:
* Быстрее большинства алгоритмов при наличии больших алфавитов или длинных образцов

Вычислительная сложность:
* Лучший случай: O(n/m) — при значительных сдвигах
* Худший случай: O(nm) — при совпадении каждого символа

## Алгоритм Рабина-Карпа и его особенности

Работает с использованием хэш-функции для проверки совпадения подстроки с образцом

1) Вычисляется хэш образца и текущей подстроки текста

2) Если хэши совпадают, выполняется дополнительное сравнение символов для подтверждения

Особенности:
* Быстро проверяет наличие подстроки в тексте
* Может давать ложные совпадения, если хэши совпадают случайно

Вычислительная сложность:
* Лучший случай: O(n+m) — при отсутствии совпадений
* Худший случай: O(nm) — при частых ложных совпадениях

Эффективное применение:

Идеален для поиска нескольких подстрок в одном тексте или при работе с большим числом образцов