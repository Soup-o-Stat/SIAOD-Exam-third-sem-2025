# Иерархические структуры данных

## Определение иерархической структуры данных

**Иерархическая структура данных** — это структура, в которой элементы организованы в виде уровней, а связи между элементами образуют древовидные или графовые отношения.

* **Основные понятия:**
  - **Узел (node):** элемент структуры данных.
  - **Корень (root):** верхний узел иерархии.
  - **Лист (leaf):** узел, не имеющий потомков.
  - **Родитель и потомок:** узел верхнего уровня и узлы нижнего уровня, связанные с ним.
  - **Глубина (depth):** расстояние от корня до узла.
  - **Высота (height):** максимальная глубина дерева.

## Отношения в иерархических структурах

* **Родитель-потомок:** связь между узлом верхнего уровня и его дочерними узлами.
* **Сиблинг (sibling):** узлы, имеющие одного родителя.
* **Предок и потомок:** любой узел, находящийся на пути от корня до данного узла, и узлы, расположенные ниже в этой ветви.

## Понятие сильно ветвящегося дерева

**Сильно ветвящееся дерево** — дерево, в котором каждый узел имеет большое количество потомков. 

* **Особенности:**
  - Уменьшается высота дерева.
  - Увеличивается сложность операций с большим количеством узлов.

---

## Виды бинарных деревьев

### Идеально сбалансированное дерево
* **Определение:** дерево, в котором для каждого узла разница высоты левого и правого поддерева не превышает 1.
* **Сложности:**
  - Поиск: \( O(\log n) \).
  - Вставка: \( O(\log n) \).
  - Удаление: \( O(\log n) \).

### Дерево выражений
* **Определение:** бинарное дерево, в узлах которого хранятся операторы и операнды. Используется для представления арифметических выражений.
* **Применение:** вычисление выражений в прямом, обратном или симметричном обходе.

### Бинарное дерево поиска (BST)
* **Определение:** дерево, в котором для любого узла значения всех элементов в левом поддереве меньше, а в правом поддереве больше значения в узле.
* **Сложности:**
  - Поиск: \( O(\log n) \) в среднем, \( O(n) \) в худшем случае.
  - Вставка: \( O(\log n) \) в среднем, \( O(n) \) в худшем случае.
  - Удаление: \( O(\log n) \) в среднем, \( O(n) \) в худшем случае.

### Сбалансированное дерево
* **Определение:** дерево, в котором высота поддерживается минимально возможной для заданного числа узлов.
* **Сложности:**
  - Все операции: \( O(\log n) \).

### AVL-дерево
* **Определение:** сбалансированное бинарное дерево поиска, в котором для любого узла разница высот левого и правого поддеревьев не превышает 1.
* **Сложности:**
  - Поиск: \( O(\log n) \).
  - Вставка: \( O(\log n) \).
  - Удаление: \( O(\log n) \).
* **Сложность по памяти:** дополнительно хранится баланс-фактор (\(+1\), \(0\), \(-1\)) для каждого узла.

### Красно-черное дерево
* **Определение:** сбалансированное бинарное дерево поиска, где каждый узел окрашен в красный или черный цвет, и выполняются строгие правила для поддержания баланса.
* **Сложности:**
  - Поиск: \( O(\log n) \).
  - Вставка: \( O(\log n) \).
  - Удаление: \( O(\log n) \).
* **Сложность по памяти:** немного выше из-за хранения цвета.

### Косое дерево (Splay Tree)
* **Определение:** бинарное дерево поиска, в котором последний использованный узел перемещается к корню для оптимизации последующих операций.
* **Сложности:**
  - Все операции: \( O(\log n) \) амортизировано.
* **Применение:** реализация динамических множеств с частыми обращениями к определённым элементам.

---

## Алгоритм создания идеально сбалансированного бинарного дерева

1. Отсортировать элементы.
2. Выбрать средний элемент как корень.
3. Рекурсивно построить левое и правое поддеревья, используя оставшиеся элементы.

---

## Полное, совершенное (законченное) дерево, их определения

### Полное дерево
* **Определение:** бинарное дерево, в котором все уровни, кроме, возможно, последнего, полностью заполнены, а узлы последнего уровня заполняются слева направо.

### Совершенное (законченное) дерево
* **Определение:** бинарное дерево, в котором все уровни полностью заполнены.
* **Пример:** дерево высотой \( h \) содержит \( 2^h - 1 \) узлов.
